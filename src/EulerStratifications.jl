module EulerStratifications

export euler_stratify, get_generic_euler_char


include("utils.jl")
include("CoincidentRootLoci.jl")
include("SmoothCurves.jl")
include("ProjectiveHypersurfaces.jl")
include("VeryAffineHypersurfaces.jl")


@doc raw"""
    euler_stratify(F::MPolyRingElem, Rz::MPolyRing, Rx::MPolyRing, Iz::MPolyIdeal; very_affine=false, max_layers=Inf, randrange=-100:100, verbose=false)

Compute the complete Euler stratification for the hypersurface family defined by F, either in projective space or in the algebraic torus (very\_affine=true). Optionally limit the number of iterated Euler discriminant computations (max\_layers).

## Example

```jldoctest
julia> d, m = 2,5
(2, 5)

julia> Rz, z = graded_polynomial_ring(QQ,["z$i" for i = 1:m+1])
(Graded multivariate polynomial ring in 6 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[z1, z2, z3, z4, z5, z6])

julia> Rx, x = polynomial_ring(Rz,["x$i" for i = 1:d+1])
(Multivariate polynomial ring in 3 variables over Rz, AbstractAlgebra.Generic.MPoly{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}[x1, x2, x3])

julia> F = z[1]*x[1]^2 + z[2]*x[1]*x[2] + z[3]*x[1]*x[3] + z[4]*x[2]^2 + z[5]*x[2]*x[3] + z[6]*x[3]^2
z1*x1^2 + z2*x1*x2 + z3*x1*x3 + z4*x2^2 + z5*x2*x3 + z6*x3^2

julia> Iz = ideal([Rz(0)])
Ideal generated by
  0

julia> euler_stratify(F, Rz, Rx, Iz)
3-element Vector{Vector{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}}:
 [Ideal (0)]
 [Ideal (4*z1*z4*z6 - z1*z5^2 - z2^2*z6 + z2*z3*z5 - z3^2*z4)]
 [Ideal (4*z4*z6 - z5^2, 2*z2*z6 - z3*z5, z2*z5 - 2*z3*z4, 4*z1*z6 - z3^2, 2*z1*z5 - z2*z3, 4*z1*z4 - z2^2)]
```
"""
function euler_stratify(F, Rz, Rx, Iz; very_affine=false, max_layers=Inf, randrange=-100:100, verbose=false)
    strata = [[Iz]]
    i = 1
    while i < max_layers && strata[end] != MPolyIdeal{QQMPolyRingElem}[]
        if verbose
            println("entering layer $i")
        end
        new_strata = []
        for J in strata[i]
            if very_affine
                disc = get_euler_discriminant_veryaff(F,Rz,Rx,J;randrange = randrange, verbose = verbose)
            else
                disc = get_euler_discriminant_proj(F,Rz,Rx,J;randrange = randrange, verbose = verbose)
            end
            push!(new_strata,disc...)
        end
        new_strata = Vector{MPolyIdeal}(own_unique!(new_strata))
        push!(strata,new_strata)
        i+=1
        if verbose
            println("strata from layer $(i-1): $(new_strata)")
            println("-------------------------------------------------------------------")
        end
    end
    return [own_unique!(s) for s in strata[1:end-1]]
end


@doc raw"""
    get_generic_euler_char(stratum_ideal::MPolyIdeal, F::MPolyRingElem; very_affine=false)

Compute the signed Euler characteristic of a general member of a family of hypersurface complements, restricted to the stratum defined by stratum\_ideal of an Euler stratification. Optionally do this for a hypersurface complement in the algebraic torus (very\_affine=true)

## Example

```jldoctest
julia> d, m = 2,5
(2, 5)

julia> Rz, z = graded_polynomial_ring(QQ,["z$i" for i = 1:m+1])
(Graded multivariate polynomial ring in 6 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[z1, z2, z3, z4, z5, z6])

julia> Rx, x = polynomial_ring(Rz,["x$i" for i = 1:d+1])
(Multivariate polynomial ring in 3 variables over Rz, AbstractAlgebra.Generic.MPoly{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}[x1, x2, x3])

julia> F = z[1]*x[1]^2 + z[2]*x[1]*x[2] + z[3]*x[1]*x[3] + z[4]*x[2]^2 + z[5]*x[2]*x[3] + z[6]*x[3]^2
z1*x1^2 + z2*x1*x2 + z3*x1*x3 + z4*x2^2 + z5*x2*x3 + z6*x3^2

julia> Iz = ideal([Rz(0)])
Ideal generated by
  0

julia> I = get_euler_discriminant_proj(F, Rz, Rx, Iz)
1-element Vector{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 Ideal (4*z1*z4*z6 - z1*z5^2 - z2^2*z6 + z2*z3*z5 - z3^2*z4)

julia> get_generic_euler_char(I[1], F)
degree of ∇F restricted to H2 = 0
degree of ∇F restricted to H1 = 1
degree of ∇F restricted to H0 = 1
0
```
"""
function get_generic_euler_char(stratum_ideal, F; very_affine=false)
    zz = get_sample(stratum_ideal)
    m = length(gens(base_ring(stratum_ideal)))-1
    d = length(gens(base_ring(ideal([F]))))-1
    F_HC, X, Z = oscar_to_HC_S(F, base_ring(ideal([F])))
    F_HC_subs = subs(F_HC, Z=>zz)
    if !very_affine 
        return get_euler_char(F_HC_subs)
    else
        @var ν[1:d+1]
        L = sum([ν[i]*log(X[i]) for i = 2:d+1]) + ν[end]*log(F_HC_subs)
        L = subs(L,X[1]=>1)
        mySys = System(differentiate(L,X[2:d+1]), variables = X[2:d+1], parameters = ν)
        est = 0
        for i = 1:5
            try 
                monres = monodromy_solve(mySys)
                sols = solutions(monres)
                sols = findall(s->abs(ComplexF64.(subs(F_HC_subs, X=>[1;s])*prod(s)))>1e-8, sols)
                est = maximum([est, length(sols)])
                if est == 0
                    break
                end
            catch e 
                println("couldn't monodromy solve")
                est = 0
                break
            end
        end
        return est
    end
end


end # module EulerStratifications
