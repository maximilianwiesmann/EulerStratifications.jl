using Oscar
using HomotopyContinuation

export get_euler_discriminant_veryaff, stratify_GKZ


@doc raw"""
    get_euler_discriminant_veryaff(f::MPolyRingElem, Rz::MPolyRing, Rx::MPolyRing, Iz::MPolyIdeal; randrange=-100:100, verbose=false)

Compute the Euler discriminant of a hypersurface family defined by f ∈ Rx = Rz[x] in the algebraic torus.

## Example

```jldoctest
julia> d, m = 2,5
(2, 5)

julia> Rz, z = graded_polynomial_ring(QQ,["z$i" for i = 1:m+1])
(Graded multivariate polynomial ring in 6 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[z1, z2, z3, z4, z5, z6])

julia> Rx, x = polynomial_ring(Rz,["x$i" for i = 1:d+1])
(Multivariate polynomial ring in 3 variables over Rz, AbstractAlgebra.Generic.MPoly{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}[x1, x2, x3])

julia> Iz = ideal([Rz(0)])
Ideal generated by
  0

julia> f = z[1]*x[1]^2 + z[2]*x[1]*x[2] + z[3]*x[1]*x[3] + z[4]*x[2]^2 + z[5]*x[2]*x[3] + z[6]*x[3]^2
z1*x1^2 + z2*x1*x2 + z3*x1*x3 + z4*x2^2 + z5*x2*x3 + z6*x3^2

julia> get_euler_discriminant_veryaff(f, Rz, Rx, Iz)
7-element Vector{MPolyIdeal}:
 Ideal (z1)
 Ideal (4*z1*z6 - z3^2)
 Ideal (4*z1*z4 - z2^2)
 Ideal (4*z1*z4*z6 - z1*z5^2 - z2^2*z6 + z2*z3*z5 - z3^2*z4)
 Ideal (z4)
 Ideal (4*z4*z6 - z5^2)
 Ideal (z6)
```
"""
function get_euler_discriminant_veryaff(f, Rz, Rx, Iz; randrange=-100:100, verbose=false)
    d = length(gens(Rx))
    n = length(gens(Rz)) - 1

    # homogenize f if necessary:
    E = collect(exponents(f))
    degf = maximum([sum(e[1:d]) for e in E])
    w = degf .- [sum(e[1][1:d]) for e in collect.(exponents.(terms(f)))]
    if sum(w) != 0
        d = d+1
    end
    KK = base_ring(base_ring(parent(f)))
    # y is an auxiliary variable for saturation
    R, x, z, y = polynomial_ring(KK, :x=>1:d, :z=>1:n+1, :y=>1:1) 
    y = y[1]
    ϕ = hom(Rz, R, z)
    C = collect(Oscar.coefficients(f))
    fh = R(0)
    if sum(w) != 0
        fh = sum([Oscar.evaluate(C[i],z)*prod(x[1:d-1].^E[i])*x[d]^wi for (i, wi) in enumerate(w)])
    else
        fh = sum([Oscar.evaluate(C[i],z)*prod(x[1:d].^E[i]) for i in 1:length(w)])
    end
    Iz_bigring = ϕ(Iz)

    # likelihood ideal 
    ν = rand(randrange, d)
    I = ideal([ν[d]*x[i]*derivative(fh,x[i]) - ν[i]*fh for i = 1:d-1]) + Iz_bigring

    J = I
    for i = 1:d
        if verbose
            println("saturating by variable $i out of $(d)")
        end
        J = eliminate(J+ideal(y*x[i]-1), [y])   # saturating this way is faster
    end

    if verbose
        println("now saturating by f...")
    end
    K = eliminate(J+ideal(y*fh-1), [y])   # this is the closure in \mathbb{P}^n \times Z

    K = K + ideal(fh)
    H = ideal([R(1)])
    for i = 1:d
        if verbose
            println("eliminating on chart $i out of $(d)")
        end
        H = intersect(H, eliminate(K+ideal([x[i]-1]), x))
    end

    ψ = hom(R, Rz, [Rz.(ones(Int,d)); gens(Rz); Rz(Int(1))])
    unique_comps = own_unique!(minimal_primes(H))
    return Vector{MPolyIdeal}([ψ(uc) for uc in unique_comps])
end


@doc raw"""
    stratify_GKZ(A::Matrix{Int}; randrange=-1000:1000)

Compute the complete Euler stratification for a GKZ family defined by an integer matrix A.
Return a tuple consisting of the Euler stratification and the polynomial f defining the family of very affine hypersurfaces.

## Example

```jldoctest
julia> A = transpose([0 0; 1 1; 1 2; 2 1])
2×4 transpose(::Matrix{Int64}) with eltype Int64:
 0  1  1  2
 0  1  2  1

julia> stratify_GKZ(A)
(Vector{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}[[Ideal (0)], [Ideal (z1), Ideal (27*z1*z3*z4 + z2^3), Ideal (z4), Ideal (z3)], [Ideal (z2, z1), Ideal (z4, z1), Ideal (z3, z1), Ideal (z4, z2), Ideal (z3, z2), Ideal (z4, z3)]], z1*x1^3 + z2*x1*x2*x3 + z4*x2^2*x3 + z3*x2*x3^2)
```
"""
function stratify_GKZ(A; randrange=-1000:1000)
    deg = maximum(sum(A, dims = 1))
    Ahat = [deg.-sum(A, dims = 1); A]
    d = size(A, 1)
    m = size(A, 2) - 1
    Rz, z = graded_polynomial_ring(QQ, ["z$i" for i = 1:m+1])
    Rx, x = polynomial_ring(Rz, ["x$i" for i = 1:d+1])
    f = sum([z[i]*prod(x.^Ahat[:,i]) for i = 1:m+1])
    Iz = ideal([Rz(0)])
    return (euler_stratify(f, Rz, Rx, Iz; randrange=randrange, very_affine=true), f)
end
