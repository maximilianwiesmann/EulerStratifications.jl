using Oscar
using HomotopyContinuation

export get_euler_discriminant_veryaff, stratify_GKZ


@doc raw"""
    get_euler_discriminant_veryaff(f::MPolyRingElem, Rz::MPolyRing, Rx::MPolyRing, Iz::MPolyIdeal; randrange=-100:100, verbose=false)

Compute the Euler discriminant of a hypersurface family defined by f ∈ Rx = Rz[x] in the algebraic torus.

## Example

```jldoctest
julia> d, m = 2,5
(2, 5)

julia> Rz, z = graded_polynomial_ring(QQ,["z$i" for i = 1:m+1])
(Graded multivariate polynomial ring in 6 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[z1, z2, z3, z4, z5, z6])

julia> Rx, x = polynomial_ring(Rz,["x$i" for i = 1:d+1])
(Multivariate polynomial ring in 3 variables over Rz, AbstractAlgebra.Generic.MPoly{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}[x1, x2, x3])

julia> Iz = ideal([Rz(0)])
Ideal generated by
  0

julia> f = z[1]*x[1]^2 + z[2]*x[1]*x[2] + z[3]*x[1]*x[3] + z[4]*x[2]^2 + z[5]*x[2]*x[3] + z[6]*x[3]^2
z1*x1^2 + z2*x1*x2 + z3*x1*x3 + z4*x2^2 + z5*x2*x3 + z6*x3^2

julia> get_euler_discriminant_veryaff(f, Rz, Rx, Iz)
7-element Vector{MPolyIdeal}:
 Ideal (z1)
 Ideal (4*z1*z6 - z3^2)
 Ideal (4*z1*z4 - z2^2)
 Ideal (4*z1*z4*z6 - z1*z5^2 - z2^2*z6 + z2*z3*z5 - z3^2*z4)
 Ideal (z4)
 Ideal (4*z4*z6 - z5^2)
 Ideal (z6)
```
"""
function get_euler_discriminant_veryaff(f, Rz, Rx, Iz; randrange=-100:100, verbose=false)
    dimZ = Oscar.dim(Iz)-1
    d = length(gens(Rx))-1
    Ft, R, x, z, w, psi, phi = to_big_ring(f,Rx,Rz)
    comps = []
    dimZ = Oscar.dim(Iz) - 1 
    for i = 1:d+1
        if verbose 
            println("i = $i out of $(d+1)")
        end
        nu = rand(randrange,d+1) 
        eqs = [nu[i]*Ft - nu[end]*x[i]*derivative(Ft,x[i]) for i = 1:d]
        if verbose 
            println("boundary f = 0")
        end
        J = psi(Iz) + ideal([eqs;Ft*w-1])
        I = eliminate(J,[w])
        for j = 1:d+1
            if i != j
                if verbose 
                    println("boundary x$j = 0")
                end
                J = I + ideal([x[j]*w-1])
                I = eliminate(J,[w])
            end
        end
        E = I + ideal([prod(x)*Ft])
        E = E + ideal([x[i]-1])
        if verbose
            println("computed closure ")
        end
        EE = eliminate(E,x)
        if verbose
            println("eliminated ")
        end
        push!(comps,minimal_primes(EE)...)
        comps = own_unique!(comps)
    end
    unique_comps = own_unique!(comps)
    phi = hom(R,Rz,[Rz.(ones(Int,d+1));gens(Rz);Rz(1)])
    return Vector{MPolyIdeal}([phi(uc) for uc in unique_comps])
end


@doc raw"""
    stratify_GKZ(A::Matrix{Int}; randrange=-1000:1000)

Compute the complete Euler stratification for a GKZ family defined by an integer matrix A.
Return a tuple consisting of the Euler stratification and the polynomial f defining the family of very affine hypersurfaces.

## Example

```jldoctest
julia> A = transpose([0 0; 1 1; 1 2; 2 1])
2×4 transpose(::Matrix{Int64}) with eltype Int64:
 0  1  1  2
 0  1  2  1

julia> stratify_GKZ(A)
(Vector{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}[[Ideal (0)], [Ideal (z1), Ideal (27*z1*z3*z4 + z2^3), Ideal (z4), Ideal (z3)], [Ideal (z2, z1), Ideal (z4, z1), Ideal (z3, z1), Ideal (z4, z2), Ideal (z3, z2), Ideal (z4, z3)]], z1*x1^3 + z2*x1*x2*x3 + z4*x2^2*x3 + z3*x2*x3^2)
```
"""
function stratify_GKZ(A; randrange=-1000:1000)
    deg = maximum(sum(A, dims = 1))
    Ahat = [deg.-sum(A, dims = 1); A]
    d = size(A, 1)
    m = size(A, 2) - 1
    Rz, z = graded_polynomial_ring(QQ, ["z$i" for i = 1:m+1])
    Rx, x = polynomial_ring(Rz, ["x$i" for i = 1:d+1])
    f = sum([z[i]*prod(x.^Ahat[:,i]) for i = 1:m+1])
    Iz = ideal([Rz(0)])
    return (euler_stratify(f, Rz, Rx, Iz; randrange=randrange, very_affine=true), f)
end
